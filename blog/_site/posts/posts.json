[
  {
    "path": "posts/2022-08-30-datos-para-netica/",
    "title": "Prepara datos para modelar",
    "description": "Procedimiento de preparción de datos a partir de GeoTiffs para producir datos tabulares\nmás adecuados para el análisis estadístico.",
    "author": [
      {
        "name": "Miguel Equihua Zamora",
        "url": {}
      }
    ],
    "date": "2022-08-30",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\nAunque este proceso puede hacerse con la nueva biblioteca\r\nterra. Se dice que la biblioteca raster es más\r\neficiente y conveniente para hacer la tarea que nos proponemos resolver,\r\nsin embargo, terra está evolucionando y podría ya no ser así.\r\nLo que haremos aquí es leer un montón de archivos raster en\r\nformato GeoTiff. Generaremos una colección congruente con ellos\r\nen términos de que comparten proyección y extensión y luego haremos una\r\ntransformación de los objetos de datos para producir una tabla\r\nconvencional de datos.\r\nLocalización de los archivos\r\nEn la seción de ayer usamos la biblioteca tools y de ella la\r\nfunción list_files_with_exts. Volvamos a hacerlo.\r\n\r\n\r\nlibrary(\"tools\")\r\nmapas_dir <- \"../../../data/indep_vars\"\r\n\r\n# Lista de los rasters considerados variables explicativas.\r\nlst_gtif <- list_files_with_exts(mapas_dir, exts = \"tif\")\r\nlst_gtif\r\n\r\n [1] \"../../../data/indep_vars/AlturaFusteLimpio_desvest_250m.tif\"\r\n [2] \"../../../data/indep_vars/AlturaFusteLimpio_media_250m.tif\"  \r\n [3] \"../../../data/indep_vars/AlturaTotal_desvest_250m.tif\"      \r\n [4] \"../../../data/indep_vars/AlturaTotal_media_250m.tif\"        \r\n [5] \"../../../data/indep_vars/DiametroCopa_desvest_250m.tif\"     \r\n [6] \"../../../data/indep_vars/DiametroCopa_media_250m.tif\"       \r\n [7] \"../../../data/indep_vars/DiametroNormal_desvest_250m.tif\"   \r\n [8] \"../../../data/indep_vars/DiametroNormal_media_250m.tif\"     \r\n [9] \"../../../data/indep_vars/hemerobia_250m.tif\"                \r\n[10] \"../../../data/indep_vars/net_photo_mean.tif\"                \r\n[11] \"../../../data/indep_vars/net_photo_mean_lluvias.tif\"        \r\n[12] \"../../../data/indep_vars/net_photo_mean_secas.tif\"          \r\n[13] \"../../../data/indep_vars/net_photo_sd.tif\"                  \r\n[14] \"../../../data/indep_vars/presenciaArbolesMuertos_250m.tif\"  \r\n[15] \"../../../data/indep_vars/presenciaInsectos_250m.tif\"        \r\n[16] \"../../../data/indep_vars/propor_bosque.tif\"                 \r\n[17] \"../../../data/indep_vars/propor_pastizaloagricultura.tif\"   \r\n[18] \"../../../data/indep_vars/propor_selva.tif\"                  \r\n[19] \"../../../data/indep_vars/propor_suelodesnudo.tif\"           \r\n[20] \"../../../data/indep_vars/propor_urbano.tif\"                 \r\n[21] \"../../../data/indep_vars/srtm90m_mean250m.tif\"              \r\n[22] \"../../../data/indep_vars/srtm90m_range250m.tif\"             \r\n[23] \"../../../data/indep_vars/zvh_31_lcc_h.tif\"                  \r\n\r\nPueden ver que hemos encontrado 25 capas de información. Cada una de\r\nellas aportará una columna de datos a nuestra tabla. Para hacer esto lo\r\nque haremos es:\r\nLeer los GeoTiff uno a la vez y agregarlo a una colección\r\nbrick\r\nConvertir la colección de objectos raster a una colección de puntos\r\n*vectoriales.\r\nConvertir los puntos en una tabla en la que cada capa aporta una\r\ncolumna.\r\nLa tabla que queremos debería tener valores para todas las\r\nvariablesNoté que rasterToPoints deja pasar algunos datos faltantes que\r\nno deberían faltar!!!, Quizás sean resultado de algunas incongruencias\r\nen la representación geográfica entre los mapas. Desde luego el tema\r\npodría requerir una valoración más cuidadosa, pero para fines prácticos\r\nse puede optar por generar una tabla en la que todas las columnas tienen\r\ndatos. La función de R complete.cases()permite\r\nincorporar esta consideración en la construcción de la tabla para omitir\r\ntodos los registros (casos o renglones) que no tengan valores válidos\r\npara todas las variables. Esto lo hace terra en forma\r\npredeterminada, así que en este caso también sirve para obtener un\r\nresultado comparable.\r\n\r\n\r\nlibrary(raster)\r\nlibrary(terra)\r\n\r\ntiempo_inicio <- Sys.time()\r\ndatos_brk <- brick(lst_gtif[1])         # tengo que iniciar el ladrillo, así que lo hago aquí\r\nfor (r in lst_gtif[2:length(lst_gtif)]) # como ya use este mapa, el ciclo empieza en el mapa 2\r\n{\r\n  datos_brk <- addLayer(datos_brk, raster(r))\r\n}\r\n\r\ndatos_tbl <- as.data.frame(rasterToPoints(datos_brk)) # aquí ocurre la magia: imágen a tabla!!\r\ndatos_tbl <- datos_tbl[complete.cases(datos_tbl), ]   # elimina filas con datos incompletos\r\ntiempo_fin = Sys.time()\r\ntiempo_raster <- tiempo_fin - tiempo_inicio\r\n\r\ndatos_tbl_na <- as.data.frame(rasterToPoints(datos_brk)) # tabla con todo\r\ndatos_tbl_na <- datos_tbl_na[!complete.cases(datos_tbl_na),] # tabla con casos incompletos\r\n\r\n\r\nCon fines didácticos y si no por llana curiosidad, les propongo\r\ncomparar el tiempo que nos toma hacer la tarea que nos propusimos con la\r\nbiblioteca raster, en contraste con el que nos toma hacerlo con\r\nla biblioteca terra.\r\n\r\n\r\nlibrary(sf)\r\n# La misma tarea de conversión de geotiffs a tabla, pero ahora con terra\r\ntiempo_inicio <- Sys.time()\r\ndatos_trr <- rast(lst_gtif)    # no necesito un for, ddirectamente procesa la lista de archivos\r\ndatos_trr_v <- as.points(datos_trr, na.rm = TRUE) # convierte en vectorial de puntos \r\n\r\ndatos_trr_sf <- st_as_sf(datos_trr_v, coords = c(\"x\", \"y\"))\r\n\r\ncoords_trr <- as.data.frame(st_coordinates(datos_trr_sf$geometry))\r\ndatos_trr_df <- as.data.frame(datos_trr_sf)\r\ndatos_trr_tbl <- cbind(coords_trr, datos_trr_df)\r\ndatos_trr_tbl <- datos_trr_tbl[, -length(datos_trr_tbl)]  # elimino la última columna (geometry)\r\ntiempo_fin = Sys.time()\r\ntiempo_terra <- tiempo_fin - tiempo_inicio\r\n\r\n\r\nCOmparación de tiempos\r\nBiblioteca\r\ntiempo\r\nRaster\r\n15.4574320316315\r\nTerra\r\n14.5813980102539\r\nLos procesos que aplicamos ¿producen los mismos resultados?. Podemos\r\nusar esté código para explorar la cuestión\r\n\r\nLas tablas raster y terra:\r\n¿Tienen la misma estructura? TRUE \r\n¿Tienen los mismos datos? TRUE \r\n\r\nGuardar la tabla en disco\r\nAhora sólo resta guardar los datos en algun lugar de mi conveniencia.\r\nLo haré en este caso con la biblioteca data.table que\r\nes super eficiente para datos grandes, así que conviene que la conozcan.\r\nEsta biblioteca contiene la función fwrite que es la que\r\nutilizaremos. Crearemos un archivo csv\r\n(valores-separados-por-comas). Anote las opciones que requiero para\r\nhacer el archivo csv como lo necesito. En\r\nR el símbolo “#” indica que lo que sigue la máquina no\r\ndebe interpretarlo, así que puede usarse para añadir comentarios para el\r\nconsumo humano.\r\n\r\n\r\nlibrary(data.table)\r\nfwrite(datos_tbl, # datos obtenidos en el proceso anterior\r\n          file = paste0(mapas_dir, \"/datos_yuc_2018.csv\"), # destino y nombre del archivo\r\n                        sep = \",\",           # La coma que separa los valores\r\n                        quote = FALSE,       # No quiero que ponga los nombres entre comillas\r\n                        na = \"*\",            # Netica utiliza * como indicador de dato faltante\r\n                        row.names = FALSE,   # No quiero una primera columna de números \"id\"\r\n                        showProgress = FALSE)# No necesito una barra de progreso\r\n\r\n\r\nCon este proceso hemos preparado una tabla de datos adecuada para ser\r\nleída en NETICA y podemos continuar con el procedimiento de construcción\r\nde los datos que utilizaremos en la contabilidad.\r\nEn Netica se necesitará un pequeño archivo de control que\r\nespecifica los datos que deseamos recuperar al procesar un nuevo archivo\r\nde datos. Para simplificar las cosas lo haremos desde aquí.\r\n\r\n\r\n\r\nMapear resultados de Netica\r\nUna vez entrenado el modelo de red bayesiana y procesados\r\nlos casos base para el mapeo, tenemos un mapa de valore\r\npredichos. Dada la especificación del archivo de\r\ncontrol, ese archivo de salida tendrá una sola columna y tantos\r\nrenglones como los que tenemos en el archivo de datos utilizaado como\r\nfuente de evidencia. El orden de los casos es también el mismo del\r\narchivo de datos, así que podemos agregar la nueva comuna del índice de\r\nintegridad a la tabla que procesamos anteriormente para generar los\r\ndatos.\r\n\r\nTable 1: Datos lat-lon e iie\r\nx\r\ny\r\niie\r\n3935625\r\n1135375\r\n15.43778\r\n3932125\r\n1135125\r\n68.02300\r\n3932375\r\n1135125\r\n80.22961\r\n3932625\r\n1135125\r\n83.39072\r\n3932875\r\n1135125\r\n78.98461\r\n3933125\r\n1135125\r\n81.42372\r\n\r\nYa tenemos una nueva tabla que incluye coordenadas lat-lon, y el\r\nnuevo dato del índice de integridad ecosistémica. Sólo\r\nresta convertir estos datos en en una tabla adecuada para representación\r\nespacial y a partir de ahí generar el GeoTiff que\r\nrepresente el resultado que obtuvimos.\r\n\r\n[1] \"SpatialPixelsDataFrame\"\r\nattr(,\"package\")\r\n[1] \"sp\"\r\n\r\n\r\nAhora convierto esta estructura de dato en uun objeto raster,\r\nefectivamente será ya el mapa final en memoria. El que guuardaremos en\r\ndisco finalmente.\r\n\r\ntamaño x, y del pixel:  250 250\r\n\r\n\r\nHemos llegado al final del proceso y ya tenemos el mapa del índice de\r\nintegridad ecosistémica en el disco.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-30-datos-para-netica/../../figuras/Proceso_datos_redes.jpg",
    "last_modified": "2022-08-31T01:29:14-05:00",
    "input_file": "datos-para-netica.knit.md"
  },
  {
    "path": "posts/2022-08-30-resultados/",
    "title": "Resultados",
    "description": "Generación de reportes dinámicos y análisis con datos embebidos. Procesos reproducibles de integración analítica de reportes para consumo humano.",
    "author": [
      {
        "name": "Miguel Equihua Zamora",
        "url": {}
      }
    ],
    "date": "2022-08-30",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\nR Markdown\r\nEste es un documento de R Markdown. Markdown es una sintáxis simple\r\npara editar HTMLs, PDFs y documentos de Microsoft Word. Para más\r\ndetalles ver: http://rmarkdown.rstudio.com.\r\nCuando presionas el botón Knit un documento será\r\ngenerado que incluye tanto el texto plano que incluyas, como código\r\nHTML, código matemático LaTeX y código R. Estos pueden ser desplegados\r\npara fines didácticos o pueden ser ocultados para simplemente generar un\r\ndocumento sin código.\r\nSi escribo la opción **echo = FALSE** el código no es\r\ndesplegado, por eso, en este caso, lo he puesto en\r\nTRUE. Hay varias opciónes para el bloque de\r\ncódigo que permiten controlar los resultados y como se presentan al\r\nlector humano.\r\nDistribución de\r\nIE por municipio para Yucatán\r\nPor poner un ejemplo podemos cargar el mapa de IE correspondiente al\r\nestado de Yucatán utilizando la biblioteca terra.\r\n\r\n\r\nlibrary(\"terra\")\r\n\r\nie_yucatan <- rast(\"../../../data/ie/ie_yucatan_2018.tif\")\r\n\r\n\r\nLuego podemos cargar un shapefile de los municipios del estado.\r\n\r\n\r\nmu_yucatan <- vect(\"../../../data/shapefiles/Basemap_municipios.shp\")\r\n\r\n\r\nPero como podemos ver tienen proyecciones ligeramente distintas.\r\n\r\n\r\ncrs(ie_yucatan, proj = TRUE)\r\n\r\n[1] \"+proj=lcc +lat_0=12 +lon_0=-102 +lat_1=17.5 +lat_2=29.5 +x_0=2500000 +y_0=0 +datum=WGS84 +units=m +no_defs\"\r\n\r\ncrs(mu_yucatan, proj = TRUE)\r\n\r\n[1] \"+proj=lcc +lat_0=12 +lon_0=-102 +lat_1=17.5 +lat_2=29.5 +x_0=2500000 +y_0=0 +ellps=GRS80 +units=m +no_defs\"\r\n\r\nPodemos asignar el sistema de coordenadas de referencia del shapefile\r\n“al vuelo”.\r\n\r\n\r\nmu_yucatan <- project(mu_yucatan, crs(ie_yucatan))\r\n\r\n\r\nLuego extraer los pixeles correspondientes a cada municipio.\r\n\r\n\r\nmu_yucatan_ei <- extract(ie_yucatan, mu_yucatan)\r\nmu_yucatan_ei <- mu_yucatan_ei[complete.cases(mu_yucatan_ei),]\r\n\r\n\r\nPara luego, finalmente, ver la distribución de IE por municipio:\r\n\r\n\r\nlibrary(\"ggplot2\")\r\nlibrary(\"ggridges\")\r\nlibrary(\"tidyverse\")\r\n\r\nmu_yucatan_ei <- right_join(mu_yucatan_ei, as.data.frame(mu_yucatan), \r\n                            by = c(\"ID\" = \"OID\"))\r\n\r\nmu_mean <- group_by(mu_yucatan_ei, NOMGEO) %>%\r\n           summarise(meanei = mean(ie_yucatan_2018, na.rm = TRUE))%>%\r\n            arrange(-meanei)\r\n\r\nmu_yucatan_ei$NOMGEO <- factor(mu_yucatan_ei$NOMGEO,\r\n                                levels = rev(mu_mean$NOMGEO))\r\n                     \r\nggplot(mu_yucatan_ei,\r\n       aes(x = ie_yucatan_2018, y = NOMGEO, fill = \"darkred\")) +\r\n  geom_density_ridges(fill = \"dark red\", alpha = 0.6) +\r\n  theme_ridges() + \r\n  xlim(0, 1)+\r\n  theme(\r\n    legend.position=\"none\",\r\n    panel.spacing = unit(0.1, \"lines\"),\r\n    strip.text.x = element_text(size = 8)) +\r\n  xlab(\"Integridad Ecosistémica\") + \r\n  ylab(\" \")\r\n\r\n\r\n\r\nReporte dinámico basado en\r\ndatos\r\nHay una tendencia actual a la producción de de documentos\r\nvivos. Es el caso de este trabajo sobre procesos\r\nreproducibles de análisis. En el mismo sentido están surgiendo\r\ncapacidades como las del officeverse, con el\r\ninterés de vincular herramientas de office con R. Aries mismo, en el\r\n“ecosistema SEEA EA” avanza en esta misma dirección.\r\n\r\n\r\n\r\nUn poco en esta misma tónica hicimos un ensayo en el piloto\r\nNCAVES. Produjimos un reporte dinámico. Les mostraremos el código\r\nque desarrollamos para hacer esto, usando R y RMarkdown precisamente y\r\ntambién les mostraremos el resultado.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-30-resultados/../../figuras/resultados.jpg",
    "last_modified": "2022-08-30T02:29:37-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-08-29-interoperabilidad/",
    "title": "Interoperabilidad",
    "description": "La interoperabilidad es fundamental para la operación intersectorial e incluso\ninterdisciplinar.",
    "author": [
      {
        "name": "Miguel Equihua Zamora",
        "url": {}
      }
    ],
    "date": "2022-08-29",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\nLa multiplicidad de descriptores del entorno natural hacen necesario\r\nconsiderar enfoque que permitan la interoperabilidad y favorezcan la\r\ncompartición de conceptos fundamentales, como los derivados del sistema\r\nde contabilidad ambiental. En este casoel índice de condición:\r\nintegridad ecosistémica basado en el modelo de 3 capas.\r\n\r\nEl participante conoce la posibilidad de utilizar una aproximación\r\nprobabilística basada en redes bayesianas para relacionar distintos\r\níndices de condición.\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-29-interoperabilidad/../../figuras/interoperabilidad.png",
    "last_modified": "2022-08-30T02:34:08-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-08-28-calculo-de-iie-actual/",
    "title": "Calculo de IIE actual",
    "description": "Conceptos, herramientas y mecanísmo de cálculo usado para el cómputo del\níndice de integridad ecosistémica basado en redes bayesianas.",
    "author": [
      {
        "name": "Miguel Equihua Zamora",
        "url": {}
      }
    ],
    "date": "2022-08-28",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\nEn esta presentación se describen los conceptos utilizados para\r\nintegrar la estrategia analítica basada en redes bayesianas que\r\ncondujo al cómputo del índice de integridad ecosistémica que se empleó\r\nen el proyecto piloto NCAVES\r\nen el que participó México. Así se obtuvieron estimadores de\r\ncondición para todos los ecosistemas del país en pixeles con resolución\r\nde 250m. Las fechas nominales de estos cálculos son 2004 y 2018. En esta\r\ncharla nos proponemos el siguiente objetivo.\r\n\r\nEl participante conoce la metodología para el cálculo del índice de\r\nintegridad ecosistémica (IIE) y las oportunidades que ofrece la\r\naproximación empleada.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-28-calculo-de-iie-actual/../../figuras/datos_geoespaciales.png",
    "last_modified": "2022-08-29T01:23:51-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-08-27-conceptos-clave/",
    "title": "Conceptos clave",
    "description": "Se describen los principales conceptos y definiciones operativas usadas en el\nsistema de contabilidad ambiental basada en ecosistemas (SEEA EA)",
    "author": [
      {
        "name": "Octavio Pérez Maqueo",
        "url": {}
      }
    ],
    "date": "2022-08-27",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\nEn esta presentación buscamos compartir estructura conceptual y las\r\ndefiniciones operativas de los elementos que intervienen la integración\r\nde un sistema de contabilidad ambiental y económica basado en\r\necosistemas (SCAE\r\nCE, SEEA EA en inglés). El objetivo que proponemos para esta\r\nparticipación es:\r\n\r\nEl participante identifica los conceptos clave de la tipología SCAE\r\nEA y conoce la forma como se aplicó el enfoque en el piloto mexicano\r\n\r\nLo que sigue es el vínculo a la presentación que usaremos para\r\ndiscutir el tema.\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-27-conceptos-clave/../../figuras/sp-Enfoque espacial_es.png",
    "last_modified": "2022-08-29T01:31:51-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-08-27-integracin-de-datos/",
    "title": "Integración de datos",
    "description": "Una introducción a la integración de datos espaciales para el modelado de IE.",
    "author": [
      {
        "name": "Julián Equihua",
        "url": "https://taller-cuenta-condicion.netlify.app/posts/2022-08-27-integracin-de-datos/"
      }
    ],
    "date": "2022-08-27",
    "categories": [],
    "contents": "\r\nAprendizaje de máquina (Machine learning)\r\nMétodos computacionales para aprender de datos con el fin de replicar una tarea o toma de decisión.\r\nExisten varios paradigmas en aprendizaje de máquina, con distintos objetivos:\r\nEl aprendizaje supervisado procura predecir o estimar una variable respuesta a partir de datos de entrada\r\nEl apprendizaje no supervisado procura describir estructuras interesantes en datos, donde no necesariamente hay una respuesta que predecir\r\nEl aprendizaje semi-supervisado procura utilizar datos asociados a una variable respuesta al mismo tiempo que datos sin la variable para procurar mejor estimarla. Estos es intenta explotar datos sin etiquetas para mejorar la estimación.\r\nEl aprendizaje por refuerzo intenta estimar la mejor política posible en un problema de toma de decisiones secuenciales.\r\nEjemplos de tareas de aprendizaje:\r\nPredecir si un individuo va a sobrevivir el hundimiento del Titanic,\r\nDetectar llamados de murciélagos en grabaciones ultrasónicas,\r\nClasificar especies de animales en imágenes digitales producidas a través de foto trampeo,\r\nEstimar el ingreso mensual de un hogar a partir de las características de la vivienda,\r\nDividir a los clientes de Netflix según sus gustos.\r\nRecomendar artículos a clientes de un programa de lealtad o servicio online.\r\n Ejercicio 1: De los ejemplos anteriores, cuáles consideran que corresponden a aprendizaje supervisado, cuáles a aprendizaje no supervisado y cuáles se podrían resolver con ambos?\r\nLas razones usuales para intentar resolver estos problemas computacionalmente son diversas:\r\nQuisiéramos obtener una respuesta barata, rápida, automatizada, y con suficiente exactitud y precisión. Por ejemplo, reconocer caracteres en una placa de coche de una fotografía se puede hacer por personas, pero eso es lento y costoso.\r\n\r\n\r\n\r\nIgual ver cada fotografía para detectar e identificar los animales ahí presentes toma muchísimo tiempo.\r\n\r\n\r\n\r\nQuisiéramos superar el desempeño actual de los expertos o de reglas simples utilizando datos: por ejemplo, en la decisión de dar o no un préstamo a un solicitante, puede ser posible tomar mejores decisiones con algoritmos que con evaluaciones personales o con reglas simples que toman en cuenta el ingreso mensual, por ejemplo.\r\n¿Lo mismo para la mejor toma de decisiones en cuanto al manejo de recursos naturales?\r\nTambién es de gran interés entender de manera más completa y sistemática el comportamiento de un fenómeno, identificando variables o patrones importantes.\r\n¿Dado un conjunto de datos ecológicos podemos hacer generar modelos que nos permitan ir explorando distintos aspectos de la integridad ecosistémica para generar conocimiento?\r\nDe una vez adelantamos que el acercamiento que se sigue para generar el índice de integridad propuesto es uno de aprendizaje supervisado. Existe una variable que sirve de evidencia para el nivel de condición de los distintos ecosistemas del país y a la par se tienen variables que permiten estimar y, eventualmente, explicar este nivel de condición. El único detalle importante aquí es que la evidencia es categórica, y el índice deseado es uno continuo entre 0 y 1.\r\nEl aprendizaje de máquina generalmente se lleva a cabo con ayuda de software especializado. Programas propietarios o de código abierto o comunmente utilizando lenguajes de programación. Por ejemplo R, python y Julia.\r\nRecomendamos ampliamente aprender los tres en la medida de lo posible pues ofrecen distintas posibilidades y ventajas. En esta sesión trabajaremos con R.\r\nManejo de datos y modelado en R\r\nPara comenzar carguemos unos datos ejemplo al espacio de trabajo de R.\r\n\r\n\r\n# Cargar paquetes.\r\nlibrary(\"raster\")\r\n\r\n# Cargar un geotiff a R, de hecho el que sirve como evidencia para el modelo de IE.\r\nruta_evidencia <- \"./delta_vp/hemerobia_250m.tif\"\r\nraster_evidencia <- raster(ruta_evidencia)\r\n\r\nraster_evidencia\r\n\r\n\r\nclass      : RasterLayer \r\ndimensions : 911, 1185, 1079535  (nrow, ncol, ncell)\r\nresolution : 250, 250  (x, y)\r\nextent     : 3697500, 3993750, 908000, 1135750  (xmin, xmax, ymin, ymax)\r\ncrs        : +proj=lcc +lat_0=12 +lon_0=-102 +lat_1=17.5 +lat_2=29.5 +x_0=2500000 +y_0=0 +datum=WGS84 +units=m +no_defs \r\nsource     : hemerobia_250m.tif \r\nnames      : hemerobia_250m \r\nvalues     : 0, 18  (min, max)\r\n\r\nPara aquellos que no han experimentado con lenguajes de programación para manejo y análisis de datos, acá están pasando varias cosas. Repasamos algunas de ellas.\r\nPrimero que nada, un elemento fundamental que debemos mencionar es el de una función. Una función recibe argumentos y lleva a cabo una cierta tarea (aunque suene un poco raro también puede recibir ningún argumento y llevar a cabo una tarea). Las funciones siempre tienen un nombre y los argumentos que reciben se colocan dentro de paréntesis.\r\n\r\n\r\n\r\nPor ejemplo la función library() lleva a cabo la tarea de cargar un determinado paquete de R. Un argumento que DEBE recibir es el nombre del paquete a cargar. La función raster carga un raster en el espacio de trabajo de R (en la memoria RAM) y un argumento que DEBE recibir es la ruta en el disco duro del raster que se quiere cargar.\r\nCuando una función carga algo en memoria, esto se debe asignar a un objeto. Es decir que se debe de elegir un “nombre” con el cuál referirse a lo que se está cargando. Se puede elegir cualquier nombre pero se recomienda usar unos juiciosos para recordar de qué se tratan. Para asignar en R comúnmente se usa una flechita pero también puede usarse el símbolo de igual como en otros lenguajes de programación.\r\n\r\n\r\n\r\nHemos llamado ‘raster_evidencia’ al que acabamos de cargar, con este objeto podemos ver una versión cruda del mismo dentro de R.\r\n\r\n\r\nplot(raster_evidencia)\r\n\r\n\r\n\r\n\r\nAhora bien, un raster es una estructura que puede resultar muy útil para ciertos propósitos, pero para otros no tanto. Por ejemplo para llevar a cabo un proceso de análisis exploratorio de datos, el formato más común es el de una tabla de datos. De hecho R tiene un estándar de datos ampliamente aceptado llamado tidy data donde se analiza y describe cómo deberían de ser las tablas de datos para análisis. Dejando eso de lado, generalmente existen funciones en R (y en los otros lenguajes) para pasar de un tipo de objeto (dato) a otro. Por ejemplo de un raster a una tabla de datos:\r\n\r\n\r\ntabla_evidencia <- as.data.frame(rasterToPoints(raster_evidencia))\r\n\r\nhead(tabla_evidencia)\r\n\r\n\r\n        x       y hemerobia_250m\r\n1 3939125 1135625             16\r\n2 3939375 1135625             16\r\n3 3939625 1135625             16\r\n4 3939875 1135625             16\r\n5 3940125 1135625             16\r\n6 3940375 1135625             16\r\n\r\nAcá cada fila es una observación (un píxel) y cada columna una variable coordenada x, coordenada y, el valor de hemerobia del píxel.\r\n\r\n\r\nlibrary(\"ggplot2\")\r\n\r\nggplot(tabla_evidencia, aes(hemerobia_250m, fill = cut(hemerobia_250m, 11))) +\r\n  geom_histogram(show.legend = FALSE) +\r\n  scale_fill_brewer(palette=\"Greens\")\r\n\r\n\r\n\r\n\r\n Ejercicio 2: cambiar los colores de las barras del histograma para que tengan secuencia de semáforo y que verde sea lo mejor conservado y rojo lo peor.\r\nPara nuestros propósitos conviene generar una tabla en formato tidy data que contenga cada raster que tenemos, el que acabamos de cargar (la respuesta) y los que corresponden a las variables explicativas.\r\nSe debe tener en mente que todas las funciones que existen en R han sido escritas por alguien. Así que estamos en la posibilidad de escribir nuestra propia función para lograr una tarea que nos sea útil.\r\nEscribir una función nueva en R es relativamente sencillo, prácticamente basta con darle un nombre, enlistar qué parámetros recibe, y qué hace la función con estos. Por ejemplo podemos escribir la función “elevar al cuadrado” que toma un número y lo multiplica por sí mismo.\r\n\r\n\r\nelevar_al_cuadrado <- function(numero){\r\n  cuadrado <- numero*numero\r\n  return(cuadrado)\r\n}\r\n\r\n\r\n\r\nYa que la función está definida y la hemos corrido, está cargada en el espacio de trabajo y podemos usarla.\r\n\r\n\r\nelevar_al_cuadrado(123)\r\n\r\n\r\n[1] 15129\r\n\r\nAhora debemos pensar qué requerimos para generar la tabla de datos antes mencionada, como todo en la vida hay varias maneras de resolver esto. Una posibilidad es generar una lista de los rasters, leerlos uno por uno para luego agregarlos a un raster multi-capa o multi-banda y convertir este último en una tabla. Ahora bien, el único paso algo complicado podría ser leer los rasters uno por uno, puesto que debemos de escribir un pedazo de código que itere sobre la lista de rasters. Hagamos esto paso por paso. Primero generemos una lista de los rasters (.tif) en una ruta de interés.\r\nUsaremos primero una función del paquete ‘tools’ para enlistar todos los archivos en una cierta ruta que tengan una extensión (.tif).\r\n\r\n\r\nlibrary(\"tools\")\r\n\r\n# Lista de los rasters considerados variables explicativas.\r\nruta_indep = list_files_with_exts(\"./indep_var_paths\",\r\n                                  exts = \"tif\")\r\n\r\nruta_indep\r\n\r\n\r\n [1] \"./indep_var_paths/AlturaFusteLimpio_desvest_250m.tif\"\r\n [2] \"./indep_var_paths/AlturaFusteLimpio_media_250m.tif\"  \r\n [3] \"./indep_var_paths/AlturaTotal_desvest_250m.tif\"      \r\n [4] \"./indep_var_paths/AlturaTotal_media_250m.tif\"        \r\n [5] \"./indep_var_paths/DiametroCopa_desvest_250m.tif\"     \r\n [6] \"./indep_var_paths/DiametroCopa_media_250m.tif\"       \r\n [7] \"./indep_var_paths/DiametroNormal_desvest_250m.tif\"   \r\n [8] \"./indep_var_paths/DiametroNormal_media_250m.tif\"     \r\n [9] \"./indep_var_paths/net_photo_mean.tif\"                \r\n[10] \"./indep_var_paths/net_photo_mean_lluvias.tif\"        \r\n[11] \"./indep_var_paths/net_photo_mean_secas.tif\"          \r\n[12] \"./indep_var_paths/net_photo_sd.tif\"                  \r\n[13] \"./indep_var_paths/presenciaArbolesMuertos_250m.tif\"  \r\n[14] \"./indep_var_paths/presenciaInsectos_250m.tif\"        \r\n[15] \"./indep_var_paths/propor_bosque.tif\"                 \r\n[16] \"./indep_var_paths/propor_pastizaloagricultura.tif\"   \r\n[17] \"./indep_var_paths/propor_selva.tif\"                  \r\n[18] \"./indep_var_paths/propor_suelodesnudo.tif\"           \r\n[19] \"./indep_var_paths/propor_urbano.tif\"                 \r\n[20] \"./indep_var_paths/srtm90m_mean250m.tif\"              \r\n[21] \"./indep_var_paths/srtm90m_range250m.tif\"             \r\n[22] \"./indep_var_paths/zvh_31_lcc_h.tif\"                  \r\n\r\nHay muchos tipos de objetos en R (y en todos los lenguajes de programación). Listas, arreglos, matrices, data.frames.\r\nHay distintas maneras de “recorrer” cada uno de estos objetos pero ver esto a profundidad escapa el alcance de esta sesión. Vamos a ver cómo recorrer una lista. Estas son estructuras lineales, esto es contienen objetos (¡DE CUALQUIER TIPO!) en una única dimensión y estos se pueden seleccionar dando la posición que ocupan en la lista. Como ejemplo la lista de las rutas a rasters es una con longitud 22.\r\nDe aquí que podamos, por ejemplo, elegir la ruta del décimo raster.\r\n\r\n\r\nruta_indep[10]\r\n\r\n\r\n[1] \"./indep_var_paths/net_photo_mean_lluvias.tif\"\r\n\r\nO incluso elegir sólo del 10 al 15.\r\n\r\n\r\nruta_indep[10:15]\r\n\r\n\r\n[1] \"./indep_var_paths/net_photo_mean_lluvias.tif\"      \r\n[2] \"./indep_var_paths/net_photo_mean_secas.tif\"        \r\n[3] \"./indep_var_paths/net_photo_sd.tif\"                \r\n[4] \"./indep_var_paths/presenciaArbolesMuertos_250m.tif\"\r\n[5] \"./indep_var_paths/presenciaInsectos_250m.tif\"      \r\n[6] \"./indep_var_paths/propor_bosque.tif\"               \r\n\r\nLo que haremos con esto es leer los rasters uno por uno utilizando un bucle. Los bucles (for loops) son de los paradigmas de iteración más comunes y viejos que hay. De nuevo hay muchas maneras de resolver esto. Si bien no es de las maneras más elegantes de lograr esto, es de utilidad puesto que siempre será posible utilizarlo, en cualquier lenguaje de programación, por lo universal que es.\r\nPrimero un bucle sencillo. Le diremos a la computadora, quiero que cuentes del 1 al 10 y en cada número digas la palabra ‘número’:\r\n\r\n\r\nfor (i in 1:10){ # Esto se lee para i que tomará los valores 1,2,3,...,10\r\n  print(\"numero\") # Despliega el texto numero\r\n}\r\n\r\n\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n[1] \"numero\"\r\n\r\nPero también le podríamos decir, despliega el número en el que vas:\r\n\r\n\r\nfor (i in 1:10){ # Esto se lee para i que tomará los valores 1,2,3,...,10\r\n  print(i) # Despliega el número en el que vas\r\n}\r\n\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n[1] 6\r\n[1] 7\r\n[1] 8\r\n[1] 9\r\n[1] 10\r\n\r\n Ejercicio 3: escribir un bucle que lea toda nuestra lista de rasters, uno por uno.\r\nJuntando todo lo anterior podemos escribir una función que nos permita leer todos los rasters y luego con esto generar una tabla:\r\n\r\n\r\nrutasAMulti = function(dep_path,\r\n                   indep_paths){\r\n  \r\n  bnbrik = brick()\r\n  bnbrik = addLayer(bnbrik,raster(dep_path))\r\n  for (i in 1:length(indep_paths)){\r\n    bnbrik = addLayer(bnbrik,raster(indep_paths[i]))\r\n  }\r\n  return(bnbrik)\r\n}\r\n\r\nraster_multi <- rutasAMulti(\"./delta_vp/hemerobia_250m.tif\", ruta_indep)\r\n\r\ntabla_multi <- as.data.frame(rasterToPoints(raster_multi))\r\n\r\nhead(tabla_multi)\r\n\r\n\r\n        x       y hemerobia_250m AlturaFusteLimpio_desvest_250m\r\n1 3939125 1135625             16                     0.00000000\r\n2 3939375 1135625             16                     0.54562950\r\n3 3939625 1135625             16                     0.02781332\r\n4 3939875 1135625             16                     0.02781332\r\n5 3940125 1135625             16                     0.02781332\r\n6 3940375 1135625             16                     0.02781332\r\n  AlturaFusteLimpio_media_250m AlturaTotal_desvest_250m\r\n1                   0.00000000              0.000000000\r\n2                   1.16930819              0.693956196\r\n3                   0.03184322              0.008685708\r\n4                   0.03184322              0.008685708\r\n5                   0.03184322              0.008685708\r\n6                   0.03184322              0.008685708\r\n  AlturaTotal_media_250m DiametroCopa_desvest_250m\r\n1              0.0000000                0.02296904\r\n2              4.6368446                0.17380011\r\n3              0.0426484                0.07168859\r\n4              0.0426484                0.07168859\r\n5              0.0426484                0.07168859\r\n6              0.0426484                0.07168859\r\n  DiametroCopa_media_250m DiametroNormal_desvest_250m\r\n1              0.02391556                  0.00000000\r\n2              0.19083574                  0.78119290\r\n3              0.01392496                  0.03274944\r\n4              0.01392496                  0.03274944\r\n5              0.01392496                  0.03274944\r\n6              0.01392496                  0.03274944\r\n  DiametroNormal_media_250m net_photo_mean net_photo_mean_lluvias\r\n1                0.00000000              0                      0\r\n2                1.10098600              0                      0\r\n3                0.07778671              0                      0\r\n4                0.07778671              0                      0\r\n5                0.07778671              0                      0\r\n6                0.07778671              0                      0\r\n  net_photo_mean_secas net_photo_sd presenciaArbolesMuertos_250m\r\n1                    0            0                           NA\r\n2                    0            0                           NA\r\n3                    0            0                           NA\r\n4                    0            0                           NA\r\n5                    0            0                           NA\r\n6                    0            0                           NA\r\n  presenciaInsectos_250m propor_bosque propor_pastizaloagricultura\r\n1                     NA             0                           0\r\n2                     NA             0                           0\r\n3                     NA             0                           0\r\n4                     NA             0                           0\r\n5                     NA             0                           0\r\n6                     NA             0                           0\r\n  propor_selva propor_suelodesnudo propor_urbano srtm90m_mean250m\r\n1            0                   0      2.469136              2.0\r\n2            0                   0      0.000000              3.5\r\n3            0                   0      0.000000               NA\r\n4            0                   0      2.469136               NA\r\n5            0                   0      2.222222               NA\r\n6            0                   0      0.000000               NA\r\n  srtm90m_range250m zvh_31_lcc_h\r\n1                 0           15\r\n2                 1           15\r\n3                NA           15\r\n4                NA           15\r\n5                NA           15\r\n6                NA           15\r\n\r\nAhora podemos ajustar un primer modelo entre las variables explicativas y nuestra respuesta. Ajustaremos un modelo lineal. Por un momento dejaremos de lado la variable “zonas de vida de holdridge” [22] y también excluiremos las columnas-coordenadas.\r\n\r\n\r\ndatos_modelo <- tabla_multi[,3:24] # Quitar coordenadas y ZVH.\r\n\r\ndatos_modelo <- datos_modelo[complete.cases(datos_modelo),] # Quitar casos con valores faltantes.\r\n\r\nmodelo_lineal <- lm(hemerobia_250m~., data = datos_modelo) # Ajuste modelo. \r\n# La fórmula variable~. significa variable explicada por \"todo lo demás\".\r\n\r\nsummary(modelo_lineal)\r\n\r\n\r\n\r\nCall:\r\nlm(formula = hemerobia_250m ~ ., data = datos_modelo)\r\n\r\nResiduals:\r\n     Min       1Q   Median       3Q      Max \r\n-17.5742  -1.5425  -0.6471   1.1071  12.5245 \r\n\r\nCoefficients:\r\n                                 Estimate Std. Error t value Pr(>|t|)\r\n(Intercept)                     3.9607597  0.0747690  52.973  < 2e-16\r\nAlturaFusteLimpio_desvest_250m -0.6420698  0.0331591 -19.363  < 2e-16\r\nAlturaFusteLimpio_media_250m   -0.2972919  0.0129057 -23.036  < 2e-16\r\nAlturaTotal_desvest_250m        1.5600010  0.0235607  66.212  < 2e-16\r\nAlturaTotal_media_250m          0.3146922  0.0079551  39.559  < 2e-16\r\nDiametroCopa_desvest_250m       1.7902153  0.0461978  38.751  < 2e-16\r\nDiametroCopa_media_250m        -0.1151313  0.0156566  -7.354 1.93e-13\r\nDiametroNormal_desvest_250m    -0.1315326  0.0052809 -24.907  < 2e-16\r\nDiametroNormal_media_250m      -0.1055519  0.0040341 -26.165  < 2e-16\r\nnet_photo_mean                 -0.0457011  0.0022202 -20.584  < 2e-16\r\nnet_photo_mean_lluvias          0.0291710  0.0010958  26.621  < 2e-16\r\nnet_photo_mean_secas            0.0115336  0.0011334  10.176  < 2e-16\r\nnet_photo_sd                   -0.0029836  0.0002019 -14.778  < 2e-16\r\npresenciaArbolesMuertos_250m    4.0028680  0.0393549 101.712  < 2e-16\r\npresenciaInsectos_250m         -1.7508169  0.0332284 -52.690  < 2e-16\r\npropor_bosque                   1.1448459  1.5805864   0.724    0.469\r\npropor_pastizaloagricultura     0.0462580  0.0006884  67.198  < 2e-16\r\npropor_selva                    0.0124566  0.0006940  17.949  < 2e-16\r\npropor_suelodesnudo             0.0299204  0.0011090  26.980  < 2e-16\r\npropor_urbano                   0.1184421  0.0006473 182.983  < 2e-16\r\nsrtm90m_mean250m               -0.0008771  0.0001808  -4.851 1.23e-06\r\nsrtm90m_range250m              -0.0063388  0.0010698  -5.925 3.12e-09\r\n                                  \r\n(Intercept)                    ***\r\nAlturaFusteLimpio_desvest_250m ***\r\nAlturaFusteLimpio_media_250m   ***\r\nAlturaTotal_desvest_250m       ***\r\nAlturaTotal_media_250m         ***\r\nDiametroCopa_desvest_250m      ***\r\nDiametroCopa_media_250m        ***\r\nDiametroNormal_desvest_250m    ***\r\nDiametroNormal_media_250m      ***\r\nnet_photo_mean                 ***\r\nnet_photo_mean_lluvias         ***\r\nnet_photo_mean_secas           ***\r\nnet_photo_sd                   ***\r\npresenciaArbolesMuertos_250m   ***\r\npresenciaInsectos_250m         ***\r\npropor_bosque                     \r\npropor_pastizaloagricultura    ***\r\npropor_selva                   ***\r\npropor_suelodesnudo            ***\r\npropor_urbano                  ***\r\nsrtm90m_mean250m               ***\r\nsrtm90m_range250m              ***\r\n---\r\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n\r\nResidual standard error: 2.625 on 593781 degrees of freedom\r\nMultiple R-squared:  0.3946,    Adjusted R-squared:  0.3946 \r\nF-statistic: 1.843e+04 on 21 and 593781 DF,  p-value: < 2.2e-16\r\n\r\nAunque no es un modelo muy bueno por múltiples razones, ya nos permite contestar algunas preguntas. Por ejemplo qué pasa si ponemos un centro urbano en algún lugar?\r\n Ejercicio 4: encontrar una observación bien conservada de la tabla de datos y utilizar el modelo para estimar qué pasaría si aumenta la cantidad de clase urbana ahí. Ayuda: investigar cómo se utiliza la función predict. Las tablas se pueden recorrer igual que las listas pero naturalmente tienen dos dimensiones en vez de solo una tabla[1:2,10:22] e incluso con condiciones, e.g. tabla[tabla$hemerobia_250m == 0,]. El símbolo de pesos se refiere a elegir una columna. \r\n¿Por qué Redes Bayesianas?\r\n\r\n\r\n\r\nFigure 1:  Variables related in someway to EI.\r\n\r\n\r\n\r\nQué influencia tienen estas variables explicativas sobre lo que llamamos IE?\r\nNuestra regresión lineal diría, por ejemplo, que IE es una suma ponderada de las variables explicativas.\r\n\r\n\r\n\r\nFigure 2:  Modelo lineal.\r\n\r\n\r\n\r\nPero, por ejemplo, no estamos también interesados en cómo la presencia de depredadores tope influencian la captura de carbono?\r\n\r\n\r\n\r\nFigure 3:  Qué hay de las relaciones entre variables explicativas?.\r\n\r\n\r\n\r\nLas Redes Bayesianas nos dejan proponer estructuras entrecruzadas de correlación entre variables.\r\n\r\n\r\n\r\nFigure 4:  Modelo actual de EI.\r\n\r\n\r\n\r\nUn comentario sobre armonización de datos\r\nFinalmente se debe mencionar que lo trabajado anteriormente asume que los datos de entrada (los rasters) se encuentran armonizados, esto es que mantienen la misma resolución, proyección, extent, etc…\r\nEsto puede requerir procesos más o menos complejos, como reproyectar, agregar o desagregar píxeles, rasterizar archivos vectoriales, etc… pero todo se puede hacer con lo antes expuesto y con las funciones contenidas en los paquetes de GIS en R o en cualquier otro lenguaje como python. Por supuesto es buena idea tener un raster molde el cuál utilizar como referente.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-27-integracin-de-datos/1_license.jpeg",
    "last_modified": "2022-08-29T17:13:10-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-08-26-dinmica-del-taller/",
    "title": "Dinámica del Taller",
    "description": "Objetivos y plan de trabajo.",
    "author": [
      {
        "name": "Octavio Pérez Maqueo, Miguel Equihua Zamora y Julián Equihua Benítez",
        "url": "https://ie-gamma.net"
      }
    ],
    "date": "2022-08-26",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\nTaller sobre Cuenta de\r\nCondición\r\nLos días 29, 30 y 31 de agosto se desarrolla este taller con la\r\nparticipación de personal de INEGI y SEMARNAT. Los conductores del\r\ntaller son:\r\nOctavio Pérez Maqueo\r\nMiguel Equihua Zamora\r\nJulián Equihua Benítez\r\nAgenda del taller\r\n\r\n\r\nTema\r\n\r\n\r\nInicia\r\n\r\n\r\nTermina\r\n\r\n\r\nDuración\r\n\r\n\r\nDía 29\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nBienvenida y presentación del taller\r\n\r\n\r\n09:00\r\n\r\n\r\n09:10\r\n\r\n\r\n00:10\r\n\r\n\r\nDinámica del taller\r\n\r\n\r\n09:10\r\n\r\n\r\n09:30\r\n\r\n\r\n00:20\r\n\r\n\r\nIntroducción\r\n\r\n\r\n09:30\r\n\r\n\r\n09:50\r\n\r\n\r\n00:20\r\n\r\n\r\nConceptos clave\r\n\r\n\r\n09:50\r\n\r\n\r\n10:20\r\n\r\n\r\n00:30\r\n\r\n\r\nCáculo del índice de integridad (versión actual)\r\n\r\n\r\n10:20\r\n\r\n\r\n11:00\r\n\r\n\r\n00:40\r\n\r\n\r\nDescanso\r\n\r\n\r\n11:00\r\n\r\n\r\n11:20\r\n\r\n\r\n00:20\r\n\r\n\r\nIntegración de información\r\n\r\n\r\n11:20\r\n\r\n\r\n14:20\r\n\r\n\r\n03:00\r\n\r\n\r\nDía 30\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCálculo del índice en Nética\r\n\r\n\r\n10:00\r\n\r\n\r\n12:00\r\n\r\n\r\n02:00\r\n\r\n\r\nDescanso\r\n\r\n\r\n12:00\r\n\r\n\r\n12:20\r\n\r\n\r\n00:20\r\n\r\n\r\nPresentación de resultados\r\n\r\n\r\n12:20\r\n\r\n\r\n13:20\r\n\r\n\r\n01:00\r\n\r\n\r\n¿Nuevo índice de integridad?\r\n\r\n\r\n13:20\r\n\r\n\r\n13:50\r\n\r\n\r\n00:30\r\n\r\n\r\nInteroperabilidad\r\n\r\n\r\n13:50\r\n\r\n\r\n14:20\r\n\r\n\r\n00:30\r\n\r\n\r\nDía 31\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCreación flujo de trabajo\r\n\r\n\r\n10:00\r\n\r\n\r\n11:00\r\n\r\n\r\n01:00\r\n\r\n\r\nDiscusión por grupos\r\n\r\n\r\n11:00\r\n\r\n\r\n12:00\r\n\r\n\r\n01:00\r\n\r\n\r\nDescanso\r\n\r\n\r\n12:00\r\n\r\n\r\n12:20\r\n\r\n\r\n00:20\r\n\r\n\r\nSintesis: futuro del sistema y consideraciones estratégicas\r\n\r\n\r\n12:20\r\n\r\n\r\n13:20\r\n\r\n\r\n01:00\r\n\r\n\r\nPreguntas y respuestas\r\nHemos preparado el taller casi por completo en el repositorio\r\nTaller_cond_2022 en Github. Proponemos dar seguimiento a dudas\r\npuntuales a través de la opción de issues.\r\nEs además un espacio de aprendizaje, pues las respuestas a las preguntas\r\nque se vayan formulando quedarán almacenadas aquí y podrán ser\r\nconsultadas cuando sea necesario. Para hacer una consulta nueva\r\nsimplemente habrá que oprimir el botón de new issue e\r\ningresar la consulta en forma suficientemente detallada (quizás con\r\nalgún ejemplo) y dar seguimiento a la discusión que la acompañará hasta\r\nque se declare resuelto el asunto. Las pantallas respectivas se ilustran\r\na continuación.\r\n\r\nConsideraciones estratégicas\r\nPara reflexionar sobre aspectos estratégicos de la gestión del\r\nsistema de cuentas ambientales basadas en ecosistemas (SEEA EA),\r\nproponemos utilizar este pizarra virtual en\r\nMiro. Les solicitamos que vayan anotando ideas ahí, conforme les\r\nvayan surgiendo. Tenemos previsto tener una sesión de discusión sobre la\r\nperspectiva futura del sistema el Miércoles 1. Lo haremos con base en\r\nesta pizarra virtual.\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-26-dinmica-del-taller/../../figuras/Portada-CME-30.png",
    "last_modified": "2022-08-29T01:27:32-05:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Bienvenida al taller sobre condición ecosistémica",
    "description": "Bienvenidos a este blog que está integrado por los materiales de capacitación\ny discusión sobre el cómputo del índice de integridad ecosistémica con el enfoque\nde redes bayesianas. Este índice se utiliza en la integración de la cuenta \nde condición.",
    "author": [
      {
        "name": "Octavio Pérez Maqueo, Miguel Equihua Zamora y Julián Equihua Benítez",
        "url": "https://i-gamma.net"
      }
    ],
    "date": "2022-08-26",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-08-29T01:23:20-05:00",
    "input_file": {}
  }
]
