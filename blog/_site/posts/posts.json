[
  {
    "path": "posts/welcome/",
    "title": "Welcome to Integridad Ecosistémica",
    "description": "Welcome to our new blog, Integridad Ecosistémica. We hope you enjoy \nreading what we have to say!",
    "author": [
      {
        "name": "Nora Jones",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-08-26",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-08-26T21:03:52+02:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-08-26-clculo-del-ndice-de-ie-versin-actual/",
    "title": "Cálculo del Índice de IE (versión actual).",
    "description": "A short description of the post.",
    "author": [
      {
        "name": "Nora Jones",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-08-26",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-08-26T22:36:01+02:00",
    "input_file": "clculo-del-ndice-de-ie-versin-actual.knit.md"
  },
  {
    "path": "posts/2022-08-27-integracin-de-datos/",
    "title": "Integración de datos",
    "description": "A short description of the post.",
    "author": [
      {
        "name": "Nora Jones",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-08-27",
    "categories": [],
    "contents": "\r\nSoftware\r\nThe probabilistic graphical models ecosystems are quite large these days.Arguably a bit more developed in R than in python.\r\n\r\n\r\n\r\nProbabilistic graphical models and bayesian causal inference in general has (unfortunately?) also been very successful in the propriety software department. There are many commercial applications that have impressive tools and even great educational resources (for a price):\r\nNetica, used by us. Conabio has licenses for the application and c++ api.\r\nBayesFusion\r\nBayesiaLab\r\nHere we will be focusing on the excellent bnlearn package.\r\nDefining BNs\r\nIn general, there are many ways to define BNs. It should be noted that what is usually needed first is a set of variables (which will later correspond to nodes) and a graph structure (some format where you can infer which nodes are connected to which).\r\nThe first natural step is to just have a list of the nodes we will work with. In bnlearn this is done quite easily. For example:\r\n\r\n\r\nlibrary(\"bnlearn\")\r\n\r\nempty_graph <- empty.graph(c(\"X\", \"Y\", \"Z\"))\r\n\r\nempty_graph\r\n\r\n\r\n\r\n  Random/Generated Bayesian network\r\n\r\n  model:\r\n   [X][Y][Z] \r\n  nodes:                                 3 \r\n  arcs:                                  0 \r\n    undirected arcs:                     0 \r\n    directed arcs:                       0 \r\n  average markov blanket size:           0.00 \r\n  average neighbourhood size:            0.00 \r\n  average branching factor:              0.00 \r\n\r\n  generation algorithm:                  Empty \r\n\r\nWhich simply initializes a 3-node BN with no arcs. We can then just set some arcs with a a two column matrix: “from” -> “to”.\r\n\r\n\r\nedges = matrix(c(\"X\", \"Y\",\r\n                 \"Z\", \"Y\"),\r\n                 ncol=2, byrow=TRUE)\r\n\r\narcs(empty_graph)=edges\r\n\r\nempty_graph\r\n\r\n\r\n\r\n  Random/Generated Bayesian network\r\n\r\n  model:\r\n   [X][Z][Y|X:Z] \r\n  nodes:                                 3 \r\n  arcs:                                  2 \r\n    undirected arcs:                     0 \r\n    directed arcs:                       2 \r\n  average markov blanket size:           2.00 \r\n  average neighbourhood size:            1.33 \r\n  average branching factor:              0.67 \r\n\r\n  generation algorithm:                  Empty \r\n\r\n\r\n\r\n\r\nNotes on data availability for EI modelling\r\nThe question of what data to use to model EI is an open one. We have already mentioned that we have a supervised approach (our target node has EI labels) and that the input for our models is a pixel*variables matrix. Since our objective is to produce a spatially explicit index each column in our input data table corresponds to a flattened geo-raster image. It’s then extremely important to bare in mind that any variable can be used for EI modelling as long as it can be put in raster format. All rasters must be harmonized meaning that their extent, spatial resolution and projection be the same.\r\nAll our variables are already harmonized and can be found here and all the used code can be found in this repository.\r\nBefore we begin to use them, we should mention that there are three main approaches to definine a BN structure:\r\nExpert knowledge\r\nAutomated structure learning (algorithms)\r\nCombinations of the previous\r\nwe followed a combination of expert knowledge and structure learning to propose our EI-BN structure. It’s based on a conceptual model which relates three distinct levels (tiers) of ecosystem functioning.\r\n\r\n\r\n\r\nFigure 1:  The ecosystem integrity three-tier model.\r\n\r\n\r\n\r\nEven though we are currently working with 25 variables (TOO MANY!!!), the gist of the BN structure is something like:\r\n\r\n\r\n\r\nFigure 2:  A generic ecosystem integrity BN based on the three-tier model.\r\n\r\n\r\n\r\nDefining a BN with our variables\r\nWe have created code that allows to directly initilize a BN by reading in the list of (harmonized) rasters in a given folder as well a supplying the name of the target variable (EI).\r\n\r\n\r\n# load packages\r\nlibrary(\"tools\")\r\n\r\n# load misc functions\r\nsource(\"./R/misc_functions.R\")\r\n\r\n# List of independent variable rasters file names\r\nindep_var_paths = list_files_with_exts(\"./indep_var_paths/\",\r\n                                       exts = \"tif\",\r\n                                       full.names = FALSE)\r\n\r\n# File name of dependent variable raster to be used\r\ndep_var_file = \"hemerobia_250m.tif\"\r\n\r\nadj_matrix = data.frame(matrix(0,length(indep_var_paths)+1,\r\n                                 length(indep_var_paths)+1))\r\n\r\n# set column and row names as file names \r\n# (dependent and independent variables)\r\ncolnames(adj_matrix)=c(dep_var_file,indep_var_paths)\r\nrownames(adj_matrix)=c(dep_var_file,indep_var_paths)\r\n\r\n# Remove file extensions from dimension names\r\n# Replace \".\" and spaces with \"_\"\r\nadj_matrix = fixDimnames(adj_matrix)\r\n\r\n# write initialized adjacency matrix to disk\r\nwrite.table(adj_matrix,\"ienet_adj_v2.csv\",sep=\",\",\r\n            row.names=TRUE,col.names=NA)\r\n\r\n\r\n\r\nThe output is an empty matrix where the rows and columns correspond to the available variables. This can be uploaded to google docs to discuss with experts which nodes should be connected. This can be a very cumbersome task but luckily we have already done it for you.\r\n\r\n\r\n\r\nFigure 3:  The ecosystem integrity adjacency matrix.\r\n\r\n\r\n\r\nFitting the EI-BN\r\nNow that we have our variable list and our structure its time to fit our bayesian network. As mentionded first we need to have our data in table format. This will be produced by reading in our geo-rasters and flattening them to accomodate a single column in a data table.\r\n\r\n\r\n# load additional packages\r\nlibrary(\"raster\")\r\nlibrary(\"gRain\")\r\n\r\n# List of independent variable rasters.\r\nindep_var_paths = list_files_with_exts(\"./indep_var_paths/\",\r\n                                  exts = \"tif\")\r\n\r\n# Load dependent variable raster (will be used as base raster).\r\ndep_var_path = \"./delta_vp/hemerobia_250m.tif\"\r\n\r\n# Create raster brick where bands are [dep_var,indep_var_1,...,indep_var_n].\r\nbnbrik = bnBrick(dep_var_path,indep_var_paths)\r\n\r\n# To df and drop incomplete rows\r\nbnbrik_df = data.frame(rasterToPoints(bnbrik))\r\nbnbrik_df = bnbrik_df[complete.cases(bnbrik_df),]\r\n\r\n# User must know which variables are factors and coerce them to factor.\r\nbnbrik_df = factorCols(bnbrik_df,\r\n                       c(\"hemerobia_250m\", \"zvh_31_lcc_h\"))\r\n\r\n\r\n\r\nWe are working with discrete bayesian networks. So all nodes must be categorical. It’s a research topic in itself how to discretize continuous variables in order to maximize the information they contain. To avoid complications in the original EI-BN we simply discretized all continuous variables using 10-equal intervals. We will do the same here but using 5 to lower the overall computation time.\r\nIt should also be noted that the names of the variables that need discretizing must be supplied, but we know here that they are simply the 3rd to 24th variables/columns.\r\n\r\n\r\nnames(bnbrik_df)\r\n\r\n\r\n [1] \"x\"                              \"y\"                             \r\n [3] \"hemerobia_250m\"                 \"AlturaFusteLimpio_desvest_250m\"\r\n [5] \"AlturaFusteLimpio_media_250m\"   \"AlturaTotal_desvest_250m\"      \r\n [7] \"AlturaTotal_media_250m\"         \"DiametroCopa_desvest_250m\"     \r\n [9] \"DiametroCopa_media_250m\"        \"DiametroNormal_desvest_250m\"   \r\n[11] \"DiametroNormal_media_250m\"      \"net_photo_mean\"                \r\n[13] \"net_photo_mean_lluvias\"         \"net_photo_mean_secas\"          \r\n[15] \"net_photo_sd\"                   \"presenciaArbolesMuertos_250m\"  \r\n[17] \"presenciaInsectos_250m\"         \"propor_bosque\"                 \r\n[19] \"propor_pastizaloagricultura\"    \"propor_selva\"                  \r\n[21] \"propor_suelodesnudo\"            \"propor_urbano\"                 \r\n[23] \"srtm90m_mean250m\"               \"srtm90m_range250m\"             \r\n[25] \"zvh_31_lcc_h\"                  \r\n\r\n# User must know which variables are numeric and discretize them.\r\nbnbrik_df = discretizeCols(bnbrik_df,\r\n                           names(bnbrik_df)[3:24])\r\n\r\n\r\n\r\nNow we load the csv file that has our adjacency matrix. This is then assigned to a bnlearn network object.\r\n\r\n\r\n# Load adjacency matrix from csv.\r\nie_adj <- read.csv(\"./networks/ienet_v2.csv\", header = TRUE, row.names = 1, stringsAsFactors = FALSE)\r\nie_adj[is.na(ie_adj)] <- 0\r\n\r\n# Create a graph based on this adjacency matrix.\r\nie_graph = empty.graph(rownames(ie_adj))\r\namat(ie_graph) = as.matrix(ie_adj)\r\n\r\n\r\nie_graph\r\n\r\n\r\n\r\n  Random/Generated Bayesian network\r\n\r\n  model:\r\n   [propor_suelodesnudo][srtm90m_mean250m][srtm90m_range250m]\r\n   [zvh_31_lcc_h][propor_pastizaloagricultura|propor_suelodesnudo]\r\n   [propor_urbano|propor_pastizaloagricultura]\r\n   [hemerobia_250m|propor_pastizaloagricultura:propor_suelodesnudo:propor_urbano]\r\n   [AlturaFusteLimpio_desvest_250m|hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [AlturaFusteLimpio_media_250m|AlturaFusteLimpio_desvest_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [AlturaTotal_desvest_250m|AlturaFusteLimpio_desvest_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [AlturaTotal_media_250m|AlturaFusteLimpio_media_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [DiametroCopa_desvest_250m|AlturaTotal_desvest_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [DiametroNormal_desvest_250m|AlturaTotal_desvest_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [net_photo_mean_secas|AlturaFusteLimpio_media_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [presenciaArbolesMuertos_250m|AlturaFusteLimpio_media_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [DiametroCopa_media_250m|DiametroCopa_desvest_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [DiametroNormal_media_250m|DiametroNormal_desvest_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [net_photo_mean|hemerobia_250m:net_photo_mean_secas:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [presenciaInsectos_250m|hemerobia_250m:presenciaArbolesMuertos_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [net_photo_mean_lluvias|hemerobia_250m:net_photo_mean:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [propor_bosque|DiametroNormal_media_250m:hemerobia_250m:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [net_photo_sd|hemerobia_250m:net_photo_mean_lluvias:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n   [propor_selva|hemerobia_250m:propor_bosque:srtm90m_mean250m:srtm90m_range250m:zvh_31_lcc_h]\r\n  nodes:                                 23 \r\n  arcs:                                  84 \r\n    undirected arcs:                     0 \r\n    directed arcs:                       84 \r\n  average markov blanket size:           7.91 \r\n  average neighbourhood size:            7.30 \r\n  average branching factor:              3.65 \r\n\r\n  generation algorithm:                  Empty \r\n\r\nWe are now ready to fit the EI-BN, this is actually quite fast!!! [sadly unlike predicting with it].\r\n\r\n\r\n# Fit bayesian network.\r\nfitted = bn.fit(ie_graph, bnbrik_df[,3:25], method = \"bayes\")\r\n\r\n# We use the junction tree algorithm to create \r\n# an independence network that we can query\r\n# will be used later to predict and create the EI map.\r\nprior <- compile(as.grain(fitted))\r\n\r\n\r\n\r\nPredicting an EI index with the EI-BN.\r\nNow that we have our fitted EI-BN we simply need to predict over the whole data set.\r\nIt’s a good time to dwell a bit more deeply into the nature of our evidence for ecosystem condition.\r\nIn order to prime the hidden tier we prepared a “Delta Primary Vegetation” (DeltaPV) map, based on the hemeroby concept, that estimates the amount of transformation that vegetation shows by comparing current land cover obtained from classified satellite imagery of the year 2008 versus expected “primary vegetation”, as judged by expert opinion. The qualitative amount of change was evaluated following the criteria showed in Figure 4.\r\n\r\n\r\n\r\nFigure 4:  Description of our proposed hemeroby/deltavp levels.\r\n\r\n\r\n\r\nAs a classification task this will give us a probability for each of the 19 degradation levels (0-pristine, 18-well conserved) we have at our disposal as evidence for each and every pixel of our region of interest (the whole of Mexico but in this particular case it’s state of Yucatan).\r\nWe then proceed to use these probabilities to calculate the expectancy of the degradation levels and then standardize this over all the pixels (to 0-degraded, 1-well conserved). This is used to create the EI index map.\r\n\r\n\r\n# Prediction (takes a million years but can be trivially parallelized, TODO)\r\nprediction = predict(prior,\r\n                     response=\"hemerobia_250m\",\r\n                     newdata=bnbrik_df,\r\n                     type=\"distribution\")\r\n\r\n\r\nprobabilities <- prediction$pred$Adelt_vp_250m\r\n\r\nie_expectancy <- list()\r\nfor (i in 1:nrow(probabilities)){\r\n  print(i)\r\n  expect <- sum(as.numeric(colnames(probabilities)) * probabilities[i,])\r\n  print(expect)\r\n  ie_expectancy[[i]] <- expect\r\n}\r\n\r\nie <- unlist(ie_expectancy)\r\nie <- (18-ie)/(18)\r\n\r\nfinal_raster = data.frame(ie=ie,x=bnbrik_df$x,y=bnbrik_df$y)\r\ncoordinates(final_raster)=~x+y\r\ngridded(final_raster)=TRUE\r\nfinal_raster = raster(final_raster)\r\nprojection(final_raster)=projection(bnbrik)\r\n\r\n# save raster\r\nrf <- writeRaster(final_raster, filename=\"ie_yucatan.tif\",\r\n                  format=\"GTiff\", overwrite=TRUE)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nFigure 5:  Comparison of deltavp/hemerobia and the EI index.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-27-integracin-de-datos/./1_software.png",
    "last_modified": "2022-08-27T12:43:04+02:00",
    "input_file": "integracin-de-datos.knit.md"
  }
]
